{"version":3,"file":"initLexicalFeatures.js","names":["getFromImportMap","initLexicalFeatures","args","clientFeatures","resolvedFeatureMapArray","sanitizedEditorConfig","resolvedFeatureMap","sort","a","b","order","featureClientSchemaMap","featureClientImportMap","featureKey","resolvedFeature","ClientFeaturePayloadComponent","ClientFeature","clientFeatureProvider","importMap","payload","PayloadComponent","schemaPath","silent","clientFeatureProps","key","clientProps","generateSchemaMap","featureSchemaPath","entry","clientFieldSchemaMap","entries","startsWith","fields","componentImports","Array","isArray","payloadComponent","Object","resolvedComponent"],"sources":["../../src/utilities/initLexicalFeatures.ts"],"sourcesContent":["import type { I18nClient } from '@payloadcms/translations'\n\nimport { type ClientFieldSchemaMap, type FieldSchemaMap, type Payload } from 'payload'\nimport { getFromImportMap } from 'payload/shared'\n\nimport type {\n  BaseClientFeatureProps,\n  FeatureProviderProviderClient,\n} from '../features/typesClient.js'\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\nimport type { FeatureClientSchemaMap, LexicalRichTextFieldProps } from '../types.js'\ntype Args = {\n  clientFieldSchemaMap: ClientFieldSchemaMap\n  fieldSchemaMap: FieldSchemaMap\n  i18n: I18nClient\n  path: string\n  payload: Payload\n  sanitizedEditorConfig: SanitizedServerEditorConfig\n  schemaPath: string\n}\n\nexport function initLexicalFeatures(args: Args): {\n  clientFeatures: LexicalRichTextFieldProps['clientFeatures']\n  featureClientImportMap: Record<string, any>\n  featureClientSchemaMap: FeatureClientSchemaMap\n} {\n  const clientFeatures: LexicalRichTextFieldProps['clientFeatures'] = {}\n\n  // turn args.resolvedFeatureMap into an array of [key, value] pairs, ordered by value.order, lowest order first:\n  const resolvedFeatureMapArray = [...args.sanitizedEditorConfig.resolvedFeatureMap].sort(\n    (a, b) => a[1].order - b[1].order,\n  )\n\n  const featureClientSchemaMap: FeatureClientSchemaMap = {}\n\n  /**\n   * All modules added to the import map, keyed by the provided key, if feature.componentImports with type object is used\n   */\n  const featureClientImportMap: Record<string, any> | undefined = {}\n\n  for (const [featureKey, resolvedFeature] of resolvedFeatureMapArray) {\n    clientFeatures[featureKey] = {}\n\n    /**\n     * Handle client features\n     */\n    const ClientFeaturePayloadComponent = resolvedFeature.ClientFeature\n\n    if (ClientFeaturePayloadComponent) {\n      const clientFeatureProvider = getFromImportMap<FeatureProviderProviderClient>({\n        importMap: args.payload.importMap,\n        PayloadComponent: ClientFeaturePayloadComponent,\n        schemaPath: 'lexical-clientComponent',\n        silent: true,\n      })\n\n      if (!clientFeatureProvider) {\n        continue\n      }\n\n      const clientFeatureProps: BaseClientFeatureProps<Record<string, any>> =\n        resolvedFeature.clientFeatureProps ?? {}\n      clientFeatureProps.featureKey = resolvedFeature.key\n      clientFeatureProps.order = resolvedFeature.order\n      if (\n        typeof ClientFeaturePayloadComponent === 'object' &&\n        ClientFeaturePayloadComponent.clientProps\n      ) {\n        clientFeatureProps.clientProps = ClientFeaturePayloadComponent.clientProps\n      }\n      // As clientFeatureProvider is a client function, we cannot execute it on the server here. Thus, the client will have to execute clientFeatureProvider with its props\n      clientFeatures[featureKey] = { clientFeatureProps, clientFeatureProvider }\n    }\n\n    /**\n     * Handle sub-fields (formstate of those)\n     */\n    // The args.fieldSchemaMap generated before in buildFormState should contain all of lexical features' sub-field schemas\n    // as well, as it already called feature.generateSchemaMap for each feature.\n    // We will check for the existance resolvedFeature.generateSchemaMap to skip unnecessary loops for constructing featureSchemaMap, but we don't run it here\n    if (resolvedFeature.generateSchemaMap) {\n      const featureSchemaPath = `${args.schemaPath}.lexical_internal_feature.${featureKey}`\n\n      featureClientSchemaMap[featureKey] = {}\n\n      // Like args.fieldSchemaMap, we only want to include the sub-fields of the current feature\n      for (const [key, entry] of args.clientFieldSchemaMap.entries()) {\n        if (key.startsWith(featureSchemaPath)) {\n          featureClientSchemaMap[featureKey][key] = 'fields' in entry ? entry.fields : [entry]\n        }\n      }\n    }\n\n    if (\n      resolvedFeature.componentImports &&\n      typeof resolvedFeature.componentImports === 'object' &&\n      !Array.isArray(resolvedFeature.componentImports)\n    ) {\n      for (const [key, payloadComponent] of Object.entries(resolvedFeature.componentImports)) {\n        const resolvedComponent = getFromImportMap({\n          importMap: args.payload.importMap,\n          PayloadComponent: payloadComponent,\n          schemaPath: 'lexical-clientComponent',\n          silent: true,\n        })\n\n        featureClientImportMap[`${resolvedFeature.key}.${key}`] = resolvedComponent\n      }\n    }\n  }\n  return {\n    clientFeatures,\n    featureClientImportMap,\n    featureClientSchemaMap,\n  }\n}\n"],"mappings":"AAGA,SAASA,gBAAgB,QAAQ;AAkBjC,OAAO,SAASC,oBAAoBC,IAAU;EAK5C,MAAMC,cAAA,GAA8D,CAAC;EAErE;EACA,MAAMC,uBAAA,GAA0B,C,GAAIF,IAAA,CAAKG,qBAAqB,CAACC,kBAAkB,CAAC,CAACC,IAAI,CACrF,CAACC,CAAA,EAAGC,CAAA,KAAMD,CAAC,CAAC,EAAE,CAACE,KAAK,GAAGD,CAAC,CAAC,EAAE,CAACC,KAAK;EAGnC,MAAMC,sBAAA,GAAiD,CAAC;EAExD;;;EAGA,MAAMC,sBAAA,GAA0D,CAAC;EAEjE,KAAK,MAAM,CAACC,UAAA,EAAYC,eAAA,CAAgB,IAAIV,uBAAA,EAAyB;IACnED,cAAc,CAACU,UAAA,CAAW,GAAG,CAAC;IAE9B;;;IAGA,MAAME,6BAAA,GAAgCD,eAAA,CAAgBE,aAAa;IAEnE,IAAID,6BAAA,EAA+B;MACjC,MAAME,qBAAA,GAAwBjB,gBAAA,CAAgD;QAC5EkB,SAAA,EAAWhB,IAAA,CAAKiB,OAAO,CAACD,SAAS;QACjCE,gBAAA,EAAkBL,6BAAA;QAClBM,UAAA,EAAY;QACZC,MAAA,EAAQ;MACV;MAEA,IAAI,CAACL,qBAAA,EAAuB;QAC1B;MACF;MAEA,MAAMM,kBAAA,GACJT,eAAA,CAAgBS,kBAAkB,IAAI,CAAC;MACzCA,kBAAA,CAAmBV,UAAU,GAAGC,eAAA,CAAgBU,GAAG;MACnDD,kBAAA,CAAmBb,KAAK,GAAGI,eAAA,CAAgBJ,KAAK;MAChD,IACE,OAAOK,6BAAA,KAAkC,YACzCA,6BAAA,CAA8BU,WAAW,EACzC;QACAF,kBAAA,CAAmBE,WAAW,GAAGV,6BAAA,CAA8BU,WAAW;MAC5E;MACA;MACAtB,cAAc,CAACU,UAAA,CAAW,GAAG;QAAEU,kBAAA;QAAoBN;MAAsB;IAC3E;IAEA;;MAAA,CAGA;IACA;IACA;IACA,IAAIH,eAAA,CAAgBY,iBAAiB,EAAE;MACrC,MAAMC,iBAAA,GAAoB,GAAGzB,IAAA,CAAKmB,UAAU,6BAA6BR,UAAA,EAAY;MAErFF,sBAAsB,CAACE,UAAA,CAAW,GAAG,CAAC;MAEtC;MACA,KAAK,MAAM,CAACW,GAAA,EAAKI,KAAA,CAAM,IAAI1B,IAAA,CAAK2B,oBAAoB,CAACC,OAAO,IAAI;QAC9D,IAAIN,GAAA,CAAIO,UAAU,CAACJ,iBAAA,GAAoB;UACrChB,sBAAsB,CAACE,UAAA,CAAW,CAACW,GAAA,CAAI,GAAG,YAAYI,KAAA,GAAQA,KAAA,CAAMI,MAAM,GAAG,CAACJ,KAAA,CAAM;QACtF;MACF;IACF;IAEA,IACEd,eAAA,CAAgBmB,gBAAgB,IAChC,OAAOnB,eAAA,CAAgBmB,gBAAgB,KAAK,YAC5C,CAACC,KAAA,CAAMC,OAAO,CAACrB,eAAA,CAAgBmB,gBAAgB,GAC/C;MACA,KAAK,MAAM,CAACT,GAAA,EAAKY,gBAAA,CAAiB,IAAIC,MAAA,CAAOP,OAAO,CAAChB,eAAA,CAAgBmB,gBAAgB,GAAG;QACtF,MAAMK,iBAAA,GAAoBtC,gBAAA,CAAiB;UACzCkB,SAAA,EAAWhB,IAAA,CAAKiB,OAAO,CAACD,SAAS;UACjCE,gBAAA,EAAkBgB,gBAAA;UAClBf,UAAA,EAAY;UACZC,MAAA,EAAQ;QACV;QAEAV,sBAAsB,CAAC,GAAGE,eAAA,CAAgBU,GAAG,IAAIA,GAAA,EAAK,CAAC,GAAGc,iBAAA;MAC5D;IACF;EACF;EACA,OAAO;IACLnC,cAAA;IACAS,sBAAA;IACAD;EACF;AACF","ignoreList":[]}