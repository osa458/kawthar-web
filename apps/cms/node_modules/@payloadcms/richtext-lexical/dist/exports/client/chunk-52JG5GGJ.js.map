{
  "version": 3,
  "sources": ["../../../src/features/blocks/client/componentInline/index.tsx", "../../../src/features/blocks/client/nodes/InlineBlocksNode.tsx", "../../../src/features/blocks/server/nodes/InlineBlocksNode.tsx"],
  "sourcesContent": ["'use client'\n\nimport type { BlocksFieldClient, ClientBlock, Data, FormState } from 'payload'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { getTranslation } from '@payloadcms/translations'\nimport {\n  Button,\n  Drawer,\n  EditDepthProvider,\n  Form,\n  formatDrawerSlug,\n  FormSubmit,\n  RenderFields,\n  ShimmerEffect,\n  useConfig,\n  useDocumentForm,\n  useDocumentInfo,\n  useEditDepth,\n  useServerFunctions,\n  useTranslation,\n} from '@payloadcms/ui'\nimport { abortAndIgnore } from '@payloadcms/ui/shared'\nimport { $getNodeByKey } from 'lexical'\n\nimport './index.scss'\n\nimport { deepCopyObjectSimpleWithoutReactComponents, reduceFieldsToValues } from 'payload/shared'\nimport React, { createContext, useCallback, useEffect, useMemo, useRef } from 'react'\nimport { v4 as uuid } from 'uuid'\n\nimport type { InlineBlockFields } from '../../server/nodes/InlineBlocksNode.js'\n\nimport { useEditorConfigContext } from '../../../../lexical/config/client/EditorConfigProvider.js'\nimport { useLexicalDrawer } from '../../../../utilities/fieldsDrawer/useLexicalDrawer.js'\nimport { $isInlineBlockNode } from '../nodes/InlineBlocksNode.js'\n\ntype Props = {\n  /**\n   * Can be modified by the node in order to trigger the re-fetch of the initial state based on the\n   * formData. This is useful when node.setFields() is explicitly called from outside of the form - in\n   * this case, the new field state is likely not reflected in the form state, so we need to re-fetch\n   */\n  readonly cacheBuster: number\n  readonly className: string\n  readonly formData: InlineBlockFields\n  readonly nodeKey: string\n}\n\ntype InlineBlockComponentContextType = {\n  EditButton?: React.FC\n  initialState: false | FormState | undefined\n  InlineBlockContainer?: React.FC<{ children: React.ReactNode }>\n  Label?: React.FC\n  nodeKey?: string\n  RemoveButton?: React.FC\n}\n\nconst InlineBlockComponentContext = createContext<InlineBlockComponentContextType>({\n  initialState: false,\n})\n\nexport const useInlineBlockComponentContext = () => React.use(InlineBlockComponentContext)\n\nexport const InlineBlockComponent: React.FC<Props> = (props) => {\n  const { cacheBuster, className: baseClass, formData, nodeKey } = props\n\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n  const { i18n, t } = useTranslation<object, string>()\n  const {\n    createdInlineBlock,\n    fieldProps: { featureClientSchemaMap, initialLexicalFormState, schemaPath },\n    setCreatedInlineBlock,\n    uuid: uuidFromContext,\n  } = useEditorConfigContext()\n  const { fields: parentDocumentFields } = useDocumentForm()\n\n  const { getFormState } = useServerFunctions()\n  const editDepth = useEditDepth()\n  const firstTimeDrawer = useRef(false)\n\n  const [initialState, setInitialState] = React.useState<false | FormState | undefined>(\n    () => initialLexicalFormState?.[formData.id]?.formState,\n  )\n\n  const hasMounted = useRef(false)\n  const prevCacheBuster = useRef(cacheBuster)\n  useEffect(() => {\n    if (hasMounted.current) {\n      if (prevCacheBuster.current !== cacheBuster) {\n        setInitialState(false)\n      }\n      prevCacheBuster.current = cacheBuster\n    } else {\n      hasMounted.current = true\n    }\n  }, [cacheBuster])\n\n  const [CustomLabel, setCustomLabel] = React.useState<React.ReactNode | undefined>(\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    initialState?.['_components']?.customComponents?.BlockLabel,\n  )\n\n  const [CustomBlock, setCustomBlock] = React.useState<React.ReactNode | undefined>(\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    initialState?.['_components']?.customComponents?.Block,\n  )\n\n  const drawerSlug = formatDrawerSlug({\n    slug: `lexical-inlineBlocks-create-${uuidFromContext}-${formData.id}`,\n    depth: editDepth,\n  })\n  const { toggleDrawer } = useLexicalDrawer(drawerSlug, true)\n\n  const inlineBlockElemElemRef = useRef<HTMLDivElement | null>(null)\n  const { id, collectionSlug, getDocPreferences, globalSlug } = useDocumentInfo()\n  const { config } = useConfig()\n\n  const componentMapRenderedBlockPath = `${schemaPath}.lexical_internal_feature.blocks.lexical_inline_blocks.${formData.blockType}`\n\n  const clientSchemaMap = featureClientSchemaMap['blocks']\n\n  const blocksField: BlocksFieldClient = clientSchemaMap?.[\n    componentMapRenderedBlockPath\n  ]?.[0] as BlocksFieldClient\n\n  const clientBlock: ClientBlock | undefined = blocksField.blockReferences\n    ? typeof blocksField?.blockReferences?.[0] === 'string'\n      ? config.blocksMap[blocksField?.blockReferences?.[0]]\n      : blocksField?.blockReferences?.[0]\n    : blocksField?.blocks?.[0]\n\n  const clientBlockFields = clientBlock?.fields ?? []\n\n  // Open drawer on \"mount\"\n  useEffect(() => {\n    if (!firstTimeDrawer.current && createdInlineBlock?.getKey() === nodeKey) {\n      // > 2 because they always have \"id\" and \"blockName\" fields\n      if (clientBlockFields.length > 2) {\n        toggleDrawer()\n      }\n      setCreatedInlineBlock?.(undefined)\n      firstTimeDrawer.current = true\n    }\n  }, [clientBlockFields.length, createdInlineBlock, nodeKey, setCreatedInlineBlock, toggleDrawer])\n\n  const removeInlineBlock = useCallback(() => {\n    editor.update(() => {\n      $getNodeByKey(nodeKey)?.remove()\n    })\n  }, [editor, nodeKey])\n\n  const blockDisplayName = clientBlock?.labels?.singular\n    ? getTranslation(clientBlock?.labels.singular, i18n)\n    : clientBlock?.slug\n\n  const onChangeAbortControllerRef = useRef(new AbortController())\n  const schemaFieldsPath = `${schemaPath}.lexical_internal_feature.blocks.lexical_inline_blocks.${clientBlock?.slug}.fields`\n\n  // Initial state for newly created blocks\n  useEffect(() => {\n    const abortController = new AbortController()\n\n    const awaitInitialState = async () => {\n      /*\n       * This will only run if a new block is created. For all existing blocks that are loaded when the document is loaded, or when the form is saved,\n       * this is not run, as the lexical field RSC will fetch the state server-side and pass it to the client. That way, we avoid unnecessary client-side\n       * requests. Though for newly created blocks, we need to fetch the state client-side, as the server doesn't know about the block yet.\n       */\n      const { state } = await getFormState({\n        id,\n        collectionSlug,\n        data: formData,\n        docPermissions: { fields: true },\n        docPreferences: await getDocPreferences(),\n        documentFormState: deepCopyObjectSimpleWithoutReactComponents(parentDocumentFields),\n        globalSlug,\n        initialBlockData: formData,\n        initialBlockFormState: formData,\n        operation: 'update',\n        readOnly: !isEditable,\n        renderAllFields: true,\n        schemaPath: schemaFieldsPath,\n        signal: abortController.signal,\n      })\n\n      if (state) {\n        const newFormStateData: InlineBlockFields = reduceFieldsToValues(\n          deepCopyObjectSimpleWithoutReactComponents(state),\n          true,\n        ) as InlineBlockFields\n\n        // Things like default values may come back from the server => update the node with the new data\n        editor.update(() => {\n          const node = $getNodeByKey(nodeKey)\n          if (node && $isInlineBlockNode(node)) {\n            const newData = newFormStateData\n            newData.blockType = formData.blockType\n\n            node.setFields(newData, true)\n          }\n        })\n\n        setInitialState(state)\n        setCustomLabel(state['_components']?.customComponents?.BlockLabel)\n        setCustomBlock(state['_components']?.customComponents?.Block)\n      }\n    }\n\n    if (formData && !initialState) {\n      void awaitInitialState()\n    }\n\n    return () => {\n      abortAndIgnore(abortController)\n    }\n  }, [\n    getFormState,\n    editor,\n    nodeKey,\n    isEditable,\n    schemaFieldsPath,\n    id,\n    formData,\n    initialState,\n    collectionSlug,\n    globalSlug,\n    getDocPreferences,\n    parentDocumentFields,\n  ])\n\n  /**\n   * HANDLE ONCHANGE\n   */\n  const onChange = useCallback(\n    async ({ formState: prevFormState, submit }: { formState: FormState; submit?: boolean }) => {\n      abortAndIgnore(onChangeAbortControllerRef.current)\n\n      const controller = new AbortController()\n      onChangeAbortControllerRef.current = controller\n\n      const { state } = await getFormState({\n        id,\n        collectionSlug,\n        docPermissions: {\n          fields: true,\n        },\n        docPreferences: await getDocPreferences(),\n        documentFormState: deepCopyObjectSimpleWithoutReactComponents(parentDocumentFields),\n        formState: prevFormState,\n        globalSlug,\n        initialBlockFormState: prevFormState,\n        operation: 'update',\n        readOnly: !isEditable,\n        renderAllFields: submit ? true : false,\n        schemaPath: schemaFieldsPath,\n        signal: controller.signal,\n      })\n\n      if (!state) {\n        return prevFormState\n      }\n\n      if (submit) {\n        setCustomLabel(state['_components']?.customComponents?.BlockLabel)\n        setCustomBlock(state['_components']?.customComponents?.Block)\n      }\n\n      return state\n    },\n    [\n      getFormState,\n      id,\n      collectionSlug,\n      getDocPreferences,\n      parentDocumentFields,\n      globalSlug,\n      isEditable,\n      schemaFieldsPath,\n    ],\n  )\n  // cleanup effect\n  useEffect(() => {\n    const isStateOutOfSync = (formData: InlineBlockFields, initialState: FormState) => {\n      return Object.keys(initialState).some(\n        (key) => initialState[key] && formData[key] !== initialState[key].value,\n      )\n    }\n\n    return () => {\n      // If the component is unmounted (either via removeInlineBlock or via lexical itself) and the form state got changed before,\n      // we need to reset the initial state to force a re-fetch of the initial state when it gets mounted again (e.g. via lexical history undo).\n      // Otherwise it would use an outdated initial state.\n      if (initialState && isStateOutOfSync(formData, initialState)) {\n        setInitialState(false)\n      }\n      abortAndIgnore(onChangeAbortControllerRef.current)\n    }\n  }, [formData, initialState])\n\n  /**\n   * HANDLE FORM SUBMIT\n   */\n  const onFormSubmit = useCallback(\n    (formState: FormState, newData: Data) => {\n      newData.blockType = formData.blockType\n\n      editor.update(() => {\n        const node = $getNodeByKey(nodeKey)\n        if (node && $isInlineBlockNode(node)) {\n          node.setFields(newData as InlineBlockFields, true)\n        }\n      })\n    },\n    [editor, nodeKey, formData],\n  )\n\n  const RemoveButton = useMemo(\n    () => () => (\n      <Button\n        buttonStyle=\"icon-label\"\n        className={`${baseClass}__removeButton`}\n        disabled={!isEditable}\n        icon=\"x\"\n        onClick={(e) => {\n          e.preventDefault()\n          removeInlineBlock()\n        }}\n        round\n        size=\"small\"\n        tooltip={t('lexical:blocks:inlineBlocks:remove', { label: blockDisplayName })}\n      />\n    ),\n    [baseClass, blockDisplayName, isEditable, removeInlineBlock, t],\n  )\n\n  const EditButton = useMemo(\n    () => () => (\n      <Button\n        buttonStyle=\"icon-label\"\n        className={`${baseClass}__editButton`}\n        disabled={!isEditable}\n        el=\"button\"\n        icon=\"edit\"\n        onClick={() => {\n          toggleDrawer()\n        }}\n        round\n        size=\"small\"\n        tooltip={t('lexical:blocks:inlineBlocks:edit', { label: blockDisplayName })}\n      />\n    ),\n    [baseClass, blockDisplayName, isEditable, t, toggleDrawer],\n  )\n\n  const InlineBlockContainer = useMemo(\n    () =>\n      ({ children, className }: { children: React.ReactNode; className?: string }) => (\n        <div\n          className={[`${baseClass}__container`, baseClass + '-' + formData.blockType, className]\n            .filter(Boolean)\n            .join(' ')}\n          ref={inlineBlockElemElemRef}\n        >\n          {children}\n        </div>\n      ),\n    [baseClass, formData.blockType],\n  )\n\n  const Label = useMemo(() => {\n    if (CustomLabel) {\n      return () => CustomLabel\n    } else {\n      return () => (\n        <div>{clientBlock?.labels ? getTranslation(clientBlock?.labels.singular, i18n) : ''}</div>\n      )\n    }\n  }, [CustomLabel, clientBlock?.labels, i18n])\n\n  if (!clientBlock) {\n    return (\n      <InlineBlockContainer className={`${baseClass}-not-found`}>\n        <span>Error: Block '{formData.blockType}' not found</span>\n        {isEditable ? (\n          <div className={`${baseClass}__actions`}>\n            <RemoveButton />\n          </div>\n        ) : null}\n      </InlineBlockContainer>\n    )\n  }\n\n  return (\n    <Form\n      beforeSubmit={[\n        async ({ formState }) => {\n          // This is only called when form is submitted from drawer\n          return await onChange({ formState, submit: true })\n        },\n      ]}\n      disableValidationOnSubmit\n      el=\"div\"\n      fields={clientBlock?.fields}\n      initialState={initialState || {}}\n      onChange={[onChange]}\n      onSubmit={(formState, data) => {\n        onFormSubmit(formState, data)\n        toggleDrawer()\n      }}\n      uuid={uuid()}\n    >\n      <EditDepthProvider>\n        <Drawer\n          className={''}\n          slug={drawerSlug}\n          title={t(`lexical:blocks:inlineBlocks:${formData?.id ? 'edit' : 'create'}`, {\n            label: blockDisplayName ?? t('lexical:blocks:inlineBlocks:label'),\n          })}\n        >\n          {initialState ? (\n            <>\n              <RenderFields\n                fields={clientBlock?.fields}\n                forceRender\n                parentIndexPath=\"\"\n                parentPath=\"\" // See Blocks feature path for details as for why this is empty\n                parentSchemaPath={schemaFieldsPath}\n                permissions={true}\n                readOnly={!isEditable}\n              />\n              <FormSubmit programmaticSubmit={true}>{t('fields:saveChanges')}</FormSubmit>\n            </>\n          ) : null}\n        </Drawer>\n      </EditDepthProvider>\n      {CustomBlock ? (\n        <InlineBlockComponentContext\n          value={{\n            EditButton,\n            initialState,\n            InlineBlockContainer,\n            Label,\n            nodeKey,\n            RemoveButton,\n          }}\n        >\n          {CustomBlock}\n        </InlineBlockComponentContext>\n      ) : (\n        <InlineBlockContainer>\n          {initialState ? <Label /> : <ShimmerEffect height=\"15px\" width=\"40px\" />}\n          {isEditable ? (\n            <div className={`${baseClass}__actions`}>\n              <EditButton />\n              <RemoveButton />\n            </div>\n          ) : null}\n        </InlineBlockContainer>\n      )}\n    </Form>\n  )\n}\n", "'use client'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  type EditorConfig,\n  type LexicalEditor,\n  type LexicalNode,\n} from 'lexical'\nimport React, { type JSX } from 'react'\n\nimport type {\n  InlineBlockFields,\n  SerializedInlineBlockNode,\n} from '../../server/nodes/InlineBlocksNode.js'\n\nimport { ServerInlineBlockNode } from '../../server/nodes/InlineBlocksNode.js'\n\nconst InlineBlockComponent = React.lazy(() =>\n  import('../componentInline/index.js').then((module) => ({\n    default: module.InlineBlockComponent,\n  })),\n)\n\nexport class InlineBlockNode extends ServerInlineBlockNode {\n  static override clone(node: ServerInlineBlockNode): ServerInlineBlockNode {\n    return super.clone(node)\n  }\n\n  static override getType(): string {\n    return super.getType()\n  }\n\n  static override importJSON(serializedNode: SerializedInlineBlockNode): InlineBlockNode {\n    const node = $createInlineBlockNode(serializedNode.fields)\n    return node\n  }\n\n  override decorate(_editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    return (\n      <InlineBlockComponent\n        cacheBuster={this.getCacheBuster()}\n        className={config.theme.inlineBlock ?? 'LexicalEditorTheme__inlineBlock'}\n        formData={this.getFields()}\n        nodeKey={this.getKey()}\n      />\n    )\n  }\n\n  override exportJSON(): SerializedInlineBlockNode {\n    return super.exportJSON()\n  }\n}\n\nexport function $createInlineBlockNode(fields: Exclude<InlineBlockFields, 'id'>): InlineBlockNode {\n  return $applyNodeReplacement(\n    new InlineBlockNode({\n      fields: {\n        ...fields,\n        id: fields?.id || new ObjectID.default().toHexString(),\n      },\n    }),\n  )\n}\n\nexport function $isInlineBlockNode(\n  node: InlineBlockNode | LexicalNode | null | undefined,\n): node is InlineBlockNode {\n  return node instanceof InlineBlockNode\n}\n", "import type {\n  DOMConversionMap,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedLexicalNode,\n} from 'lexical'\nimport type { JsonObject } from 'payload'\nimport type React from 'react'\nimport type { JSX } from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement, DecoratorNode } from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\nexport type InlineBlockFields<TInlineBlockFields extends JsonObject = JsonObject> = {\n  blockType: string\n  id: string\n} & TInlineBlockFields\n\nexport type SerializedInlineBlockNode<TBlockFields extends JsonObject = JsonObject> = {\n  fields: InlineBlockFields<TBlockFields>\n} & StronglyTypedLeafNode<SerializedLexicalNode, 'inlineBlock'>\n\nexport class ServerInlineBlockNode extends DecoratorNode<null | React.ReactElement> {\n  __cacheBuster: number\n  __fields: InlineBlockFields\n\n  constructor({\n    cacheBuster,\n    fields,\n    key,\n  }: {\n    cacheBuster?: number\n    fields: InlineBlockFields\n    key?: NodeKey\n  }) {\n    super(key)\n    this.__fields = fields\n    this.__cacheBuster = cacheBuster || 0\n  }\n\n  static override clone(node: ServerInlineBlockNode): ServerInlineBlockNode {\n    return new this({\n      cacheBuster: node.__cacheBuster,\n      fields: node.__fields,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'inlineBlock'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {}\n  }\n\n  static override importJSON(serializedNode: SerializedInlineBlockNode): ServerInlineBlockNode {\n    const node = $createServerInlineBlockNode(serializedNode.fields)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  canIndent() {\n    return true\n  }\n\n  override createDOM(config?: EditorConfig): HTMLElement {\n    const element = document.createElement('span')\n    addClassNamesToElement(element, config?.theme?.inlineBlock)\n    return element\n  }\n\n  override decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element | null {\n    return null\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('span')\n    element.classList.add('inline-block-container')\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  override exportJSON(): SerializedInlineBlockNode {\n    return {\n      type: 'inlineBlock',\n      fields: this.getFields(),\n      version: 1,\n    }\n  }\n\n  getCacheBuster(): number {\n    return this.getLatest().__cacheBuster\n  }\n\n  getFields(): InlineBlockFields {\n    return this.getLatest().__fields\n  }\n\n  override getTextContent(): string {\n    return `Block Field`\n  }\n\n  override isInline() {\n    return true\n  }\n\n  setFields(fields: InlineBlockFields, preventFormStateUpdate?: boolean): void {\n    const writable = this.getWritable()\n    writable.__fields = fields\n    if (!preventFormStateUpdate) {\n      writable.__cacheBuster++\n    }\n  }\n\n  override updateDOM(): boolean {\n    return false\n  }\n}\n\nexport function $createServerInlineBlockNode(\n  fields: Exclude<InlineBlockFields, 'id'>,\n): ServerInlineBlockNode {\n  return $applyNodeReplacement(\n    new ServerInlineBlockNode({\n      fields: {\n        ...fields,\n        id: fields?.id || new ObjectID.default().toHexString(),\n      },\n    }),\n  )\n}\n\nexport function $isServerInlineBlockNode(\n  node: LexicalNode | null | ServerInlineBlockNode | undefined,\n): node is ServerInlineBlockNode {\n  return node instanceof ServerInlineBlockNode\n}\n"],
  "mappings": "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",
  "names": ["useLexicalComposerContext", "useLexicalEditable", "getTranslation", "Button", "Drawer", "EditDepthProvider", "Form", "formatDrawerSlug", "FormSubmit", "RenderFields", "ShimmerEffect", "useConfig", "useDocumentForm", "useDocumentInfo", "useEditDepth", "useServerFunctions", "useTranslation", "abortAndIgnore", "$getNodeByKey", "deepCopyObjectSimpleWithoutReactComponents", "reduceFieldsToValues", "React", "createContext", "useCallback", "useEffect", "useMemo", "useRef", "v4", "uuid", "ObjectID", "$applyNodeReplacement", "React", "addClassNamesToElement", "ObjectID", "$applyNodeReplacement", "DecoratorNode", "ServerInlineBlockNode", "__cacheBuster", "__fields", "constructor", "cacheBuster", "fields", "key", "clone", "node", "__key", "getType", "importDOM", "importJSON", "serializedNode", "$createServerInlineBlockNode", "isInline", "canIndent", "createDOM", "config", "element", "document", "createElement", "theme", "inlineBlock", "decorate", "editor", "exportDOM", "classList", "add", "text", "createTextNode", "getTextContent", "append", "exportJSON", "type", "getFields", "version", "getCacheBuster", "getLatest", "setFields", "preventFormStateUpdate", "writable", "getWritable", "updateDOM", "id", "default", "toHexString", "InlineBlockComponent", "React", "lazy", "then", "module", "default", "InlineBlockNode", "ServerInlineBlockNode", "clone", "node", "getType", "importJSON", "serializedNode", "$createInlineBlockNode", "fields", "decorate", "_editor", "config", "_jsx", "cacheBuster", "getCacheBuster", "className", "theme", "inlineBlock", "formData", "getFields", "nodeKey", "getKey", "exportJSON", "$applyNodeReplacement", "id", "ObjectID", "toHexString", "$isInlineBlockNode", "InlineBlockComponentContext", "createContext", "initialState", "useInlineBlockComponentContext", "React", "use", "InlineBlockComponent", "props", "cacheBuster", "className", "baseClass", "formData", "nodeKey", "editor", "useLexicalComposerContext", "isEditable", "useLexicalEditable", "i18n", "t", "useTranslation", "createdInlineBlock", "fieldProps", "featureClientSchemaMap", "initialLexicalFormState", "schemaPath", "setCreatedInlineBlock", "uuid", "uuidFromContext", "useEditorConfigContext", "fields", "parentDocumentFields", "useDocumentForm", "getFormState", "useServerFunctions", "editDepth", "useEditDepth", "firstTimeDrawer", "useRef", "setInitialState", "useState", "id", "formState", "hasMounted", "prevCacheBuster", "useEffect", "current", "CustomLabel", "setCustomLabel", "customComponents", "BlockLabel", "CustomBlock", "setCustomBlock", "Block", "drawerSlug", "formatDrawerSlug", "slug", "depth", "toggleDrawer", "useLexicalDrawer", "inlineBlockElemElemRef", "collectionSlug", "getDocPreferences", "globalSlug", "useDocumentInfo", "config", "useConfig", "componentMapRenderedBlockPath", "blockType", "blocksField", "clientBlock", "blockReferences", "blocksMap", "blocks", "clientBlockFields", "getKey", "length", "undefined", "removeInlineBlock", "useCallback", "update", "$getNodeByKey", "remove", "blockDisplayName", "labels", "singular", "getTranslation", "onChangeAbortControllerRef", "AbortController", "schemaFieldsPath", "abortController", "state", "data", "docPermissions", "docPreferences", "documentFormState", "deepCopyObjectSimpleWithoutReactComponents", "initialBlockData", "initialBlockFormState", "operation", "readOnly", "renderAllFields", "signal", "newFormStateData", "reduceFieldsToValues", "node", "$isInlineBlockNode", "newData", "setFields", "abortAndIgnore", "onChange", "prevFormState", "submit", "controller", "isStateOutOfSync", "Object", "keys", "some", "key", "value", "onFormSubmit", "RemoveButton", "useMemo", "_jsx", "Button", "buttonStyle", "disabled", "icon", "onClick", "e", "preventDefault", "round", "size", "tooltip", "label", "EditButton", "el", "InlineBlockContainer", "children", "filter", "Boolean", "join", "ref", "Label", "_jsxs", "Form", "beforeSubmit", "disableValidationOnSubmit", "onSubmit", "EditDepthProvider", "Drawer", "title", "_Fragment", "RenderFields", "forceRender", "parentIndexPath", "parentPath", "parentSchemaPath", "permissions", "FormSubmit", "programmaticSubmit", "ShimmerEffect", "height", "width"]
}
