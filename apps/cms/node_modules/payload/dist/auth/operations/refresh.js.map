{"version":3,"sources":["../../../src/auth/operations/refresh.ts"],"sourcesContent":["import url from 'url'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { Document, PayloadRequest } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utils.js'\nimport { Forbidden } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { jwtSign } from '../jwt.js'\nimport { removeExpiredSessions } from '../sessions.js'\n\nexport type Result = {\n  exp: number\n  refreshedToken: string\n  setCookie?: boolean\n  /** @deprecated\n   * use:\n   * ```ts\n   * user._strategy\n   * ```\n   */\n  strategy?: string\n  user: Document\n}\n\nexport type Arguments = {\n  collection: Collection\n  req: PayloadRequest\n}\n\nexport const refreshOperation = async (incomingArgs: Arguments): Promise<Result> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    if (args.collection.config.hooks?.beforeOperation?.length) {\n      for (const hook of args.collection.config.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            collection: args.collection?.config,\n            context: args.req.context,\n            operation: 'refresh',\n            req: args.req,\n          })) || args\n      }\n    }\n\n    // /////////////////////////////////////\n    // Refresh\n    // /////////////////////////////////////\n\n    const {\n      collection: { config: collectionConfig },\n      req,\n      req: {\n        payload: { config, secret },\n      },\n    } = args\n\n    if (!args.req.user) {\n      throw new Forbidden(args.req.t)\n    }\n\n    const parsedURL = url.parse(args.req.url!)\n    const isGraphQL = parsedURL.pathname === config.routes.graphQL\n\n    let user = await req.payload.db.findOne<any>({\n      collection: collectionConfig.slug,\n      req,\n      where: { id: { equals: args.req.user.id } },\n    })\n\n    const sid = args.req.user._sid\n\n    if (collectionConfig.auth.useSessions && !collectionConfig.auth.disableLocalStrategy) {\n      if (!Array.isArray(user.sessions) || !sid) {\n        throw new Forbidden(args.req.t)\n      }\n\n      const existingSession = user.sessions.find(({ id }: { id: number }) => id === sid)\n\n      const now = new Date()\n      const tokenExpInMs = collectionConfig.auth.tokenExpiration * 1000\n      existingSession.expiresAt = new Date(now.getTime() + tokenExpInMs)\n\n      // Prevent updatedAt from being updated when only refreshing a session\n      user.updatedAt = null\n\n      await req.payload.db.updateOne({\n        id: user.id,\n        collection: collectionConfig.slug,\n        data: {\n          ...user,\n          sessions: removeExpiredSessions(user.sessions),\n        },\n        req,\n        returning: false,\n      })\n    }\n\n    user = await req.payload.findByID({\n      id: user.id,\n      collection: collectionConfig.slug,\n      depth: isGraphQL ? 0 : args.collection.config.auth.depth,\n      req: args.req,\n    })\n\n    if (user) {\n      user.collection = args.req.user.collection\n      user._strategy = args.req.user._strategy\n    }\n\n    let result!: Result\n\n    // /////////////////////////////////////\n    // refresh hook - Collection\n    // /////////////////////////////////////\n\n    for (const refreshHook of args.collection.config.hooks.refresh) {\n      const hookResult = await refreshHook({ args, user })\n\n      if (hookResult) {\n        result = hookResult\n        break\n      }\n    }\n\n    if (!result) {\n      const fieldsToSign = getFieldsToSign({\n        collectionConfig,\n        email: user?.email as string,\n        sid,\n        user: args?.req?.user,\n      })\n\n      const { exp, token: refreshedToken } = await jwtSign({\n        fieldsToSign,\n        secret,\n        tokenExpiration: collectionConfig.auth.tokenExpiration,\n      })\n\n      result = {\n        exp,\n        refreshedToken,\n        setCookie: true,\n        /** @deprecated\n         * use:\n         * ```ts\n         * user._strategy\n         * ```\n         */\n        strategy: args.req.user._strategy,\n        user,\n      }\n    }\n\n    // /////////////////////////////////////\n    // After Refresh - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRefresh?.length) {\n      for (const hook of collectionConfig.hooks.afterRefresh) {\n        result =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            exp: result.exp,\n            req: args.req,\n            token: result.refreshedToken,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'refresh',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["url","buildAfterOperation","Forbidden","commitTransaction","initTransaction","killTransaction","getFieldsToSign","jwtSign","removeExpiredSessions","refreshOperation","incomingArgs","args","shouldCommit","req","collection","config","hooks","beforeOperation","length","hook","context","operation","collectionConfig","payload","secret","user","t","parsedURL","parse","isGraphQL","pathname","routes","graphQL","db","findOne","slug","where","id","equals","sid","_sid","auth","useSessions","disableLocalStrategy","Array","isArray","sessions","existingSession","find","now","Date","tokenExpInMs","tokenExpiration","expiresAt","getTime","updatedAt","updateOne","data","returning","findByID","depth","_strategy","result","refreshHook","refresh","hookResult","fieldsToSign","email","exp","token","refreshedToken","setCookie","strategy","afterRefresh","error"],"mappings":"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"}